"use strict";
// -------------------------------------------------------------
// WARNING: this file is used by both the client and the server.
// Do not use any browser or node-specific API!
// -------------------------------------------------------------
/* eslint hammerhead/proto-methods: 2 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const regexp_escape_1 = __importDefault(require("../utils/regexp-escape"));
const internal_attributes_1 = __importDefault(require("../processing/dom/internal-attributes"));
const url_1 = require("../utils/url");
const SOURCE_MAP_RE = /(?:\/\*\s*(?:#|@)\s*sourceMappingURL\s*=[\s\S]*?\*\/)|(?:\/\/[\t ]*(?:#|@)[\t ]*sourceMappingURL[\t ]*=.*)/ig;
const CSS_URL_PROPERTY_VALUE_PATTERN = /(url\s*\(\s*)(?:(')([^\s']*)(')|(")([^\s"]*)(")|([^\s)]*))(\s*\))|(@import\s+)(?:(')([^\s']*)(')|(")([^\s"]*)("))/g;
const STYLESHEET_PROCESSING_START_COMMENT = '/*hammerhead|stylesheet|start*/';
const STYLESHEET_PROCESSING_END_COMMENT = '/*hammerhead|stylesheet|end*/';
const HOVER_PSEUDO_CLASS_RE = /:\s*hover(\W)/gi;
const PSEUDO_CLASS_RE = new RegExp(`\\[${internal_attributes_1.default.hoverPseudoClass}\\](\\W)`, 'ig');
const IS_STYLE_SHEET_PROCESSED_RE = new RegExp(`\\s*${regexp_escape_1.default(STYLESHEET_PROCESSING_START_COMMENT)}`, 'gi');
const STYLESHEET_PROCESSING_COMMENTS_RE = new RegExp(`\\s*${regexp_escape_1.default(STYLESHEET_PROCESSING_START_COMMENT)}\n?|` +
    `\n?${regexp_escape_1.default(STYLESHEET_PROCESSING_END_COMMENT)}\\s*`, 'gi');
class StyleProcessor {
    constructor() {
        this.STYLESHEET_PROCESSING_START_COMMENT = STYLESHEET_PROCESSING_START_COMMENT;
        this.STYLESHEET_PROCESSING_END_COMMENT = STYLESHEET_PROCESSING_END_COMMENT;
    }
    process(css, urlReplacer, shouldIncludeProcessingComments) {
        if (!css || typeof css !== 'string' || shouldIncludeProcessingComments && IS_STYLE_SHEET_PROCESSED_RE.test(css))
            return css;
        // NOTE: Replace the :hover pseudo-class.
        css = css.replace(HOVER_PSEUDO_CLASS_RE, '[' + internal_attributes_1.default.hoverPseudoClass + ']$1');
        // NOTE: Remove all 'source map' directives.
        css = css.replace(SOURCE_MAP_RE, '');
        // NOTE: Replace URLs in CSS rules with proxy URLs.
        css = this._replaceStylsheetUrls(css, urlReplacer);
        if (shouldIncludeProcessingComments)
            css = `${STYLESHEET_PROCESSING_START_COMMENT}\n${css}\n${STYLESHEET_PROCESSING_END_COMMENT}`;
        return css;
    }
    cleanUp(css, parseProxyUrl) {
        if (typeof css !== 'string')
            return css;
        css = css
            .replace(PSEUDO_CLASS_RE, ':hover$1')
            .replace(STYLESHEET_PROCESSING_COMMENTS_RE, '');
        return this._replaceStylsheetUrls(css, (url) => {
            const parsedProxyUrl = parseProxyUrl(url);
            return parsedProxyUrl ? parsedProxyUrl.destUrl : url;
        });
    }
    _replaceStylsheetUrls(css, processor) {
        return css.replace(CSS_URL_PROPERTY_VALUE_PATTERN, (match, prefix1, openQuote1, url1, closeQuote1, openQuote2, url2, closeQuote2, url3, postfix, prefix2, openQuote3, url4, closeQuote3, openQuote4, url5, closeQuote4) => {
            const prefix = prefix1 || prefix2;
            const openQuote = openQuote1 || openQuote2 || openQuote3 || openQuote4 || '';
            const url = url1 || url2 || url3 || url4 || url5;
            const closeQuote = closeQuote1 || closeQuote2 || closeQuote3 || closeQuote4 || '';
            postfix = postfix || '';
            const processedUrl = url_1.isSpecialPage(url) ? url : processor(url);
            return url ? prefix + openQuote + processedUrl + closeQuote + postfix : match;
        });
    }
}
exports.default = new StyleProcessor();module.exports = exports.default;

