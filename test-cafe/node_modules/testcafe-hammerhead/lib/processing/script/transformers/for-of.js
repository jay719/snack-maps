"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const esotope_hammerhead_1 = require("esotope-hammerhead");
const node_builder_1 = require("../node-builder");
const replace_node_1 = __importDefault(require("./replace-node"));
const temp_variables_1 = __importDefault(require("./temp-variables"));
// Transform:
// for (let {href, postMessage} of wins) {} -->
// for (let _hh$temp0 of wins) { let {href, postMessage} = _hh$temp0; }
const transformer = {
    nodeReplacementRequireTransform: false,
    nodeTypes: esotope_hammerhead_1.Syntax.ForOfStatement,
    condition: node => {
        let left = node.left;
        if (left.type === esotope_hammerhead_1.Syntax.VariableDeclaration)
            left = left.declarations[0].id;
        return left.type === esotope_hammerhead_1.Syntax.ObjectPattern || left.type === esotope_hammerhead_1.Syntax.ArrayPattern;
    },
    run: node => {
        const tempIdentifier = node_builder_1.createIdentifier(temp_variables_1.default.generateName());
        const forOfLeft = node.left;
        let statementWithTempAssignment;
        if (forOfLeft.type === esotope_hammerhead_1.Syntax.VariableDeclaration) {
            statementWithTempAssignment = node_builder_1.createVariableDeclaration(forOfLeft.kind, [
                node_builder_1.createVariableDeclarator(forOfLeft.declarations[0].id, tempIdentifier)
            ]);
            statementWithTempAssignment.reTransform = true;
            replace_node_1.default(forOfLeft.declarations[0].id, tempIdentifier, forOfLeft.declarations[0], 'id');
        }
        else {
            const varDeclaration = node_builder_1.createVariableDeclaration('var', [node_builder_1.createVariableDeclarator(tempIdentifier)]);
            statementWithTempAssignment = node_builder_1.createAssignmentExprStmt(forOfLeft, tempIdentifier);
            replace_node_1.default(forOfLeft, varDeclaration, node, 'left');
        }
        if (node.body.type === esotope_hammerhead_1.Syntax.BlockStatement)
            replace_node_1.default(null, statementWithTempAssignment, node.body, 'body');
        else
            replace_node_1.default(node.body, node_builder_1.createBlockStatement([statementWithTempAssignment, node.body]), node, 'body');
        return null;
    }
};
exports.default = transformer;module.exports = exports.default;

