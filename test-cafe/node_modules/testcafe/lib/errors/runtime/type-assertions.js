"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.assertType = exports.is = void 0;
const lodash_1 = require("lodash");
const _1 = require("./");
const types_1 = require("../types");
const hook_1 = __importDefault(require("../../api/request-hooks/hook"));
const test_timeout_1 = __importDefault(require("../../api/structure/test-timeout"));
const START_FROM_VOWEL_RE = /^[aeiou]/i;
function getIndefiniteArticle(text) {
    return START_FROM_VOWEL_RE.test(text) ? 'an' : 'a';
}
function isNonNegativeValue(value) {
    return lodash_1.isFinite(value) && value >= 0;
}
function getNumberTypeActualValueMsg(value, type) {
    if (type !== 'number')
        return type;
    if (Number.isNaN(value))
        return NaN;
    if (!lodash_1.isFinite(value))
        return Infinity;
    return value;
}
function hasSomePropInObject(obj, props) {
    return !!obj &&
        typeof obj === 'object' &&
        props.some(prop => prop in obj);
}
exports.is = {
    number: {
        name: 'number',
        predicate: lodash_1.isFinite,
        getActualValueMsg: getNumberTypeActualValueMsg
    },
    nonNegativeNumber: {
        name: 'non-negative number',
        predicate: isNonNegativeValue,
        getActualValueMsg: getNumberTypeActualValueMsg
    },
    nonNegativeNumberString: {
        name: 'non-negative number',
        predicate: value => isNonNegativeValue(parseInt(value, 10)),
        getActualValueMsg: value => {
            const number = parseInt(value, 10);
            return isNaN(number) ? JSON.stringify(value) : number;
        }
    },
    boolean: {
        name: 'boolean',
        predicate: (value, type) => type === 'boolean'
    },
    string: {
        name: 'string',
        predicate: (value, type) => type === 'string'
    },
    function: {
        name: 'function',
        predicate: (value, type) => type === 'function'
    },
    regExp: {
        name: 'regular expression',
        predicate: lodash_1.isRegExp
    },
    array: {
        name: 'array',
        predicate: value => Array.isArray(value)
    },
    nonNullObject: {
        name: 'non-null object',
        predicate: (value, type) => type === 'object' && !lodash_1.isNil(value),
        getActualValueMsg: (value, type) => lodash_1.isNil(value) ? String(value) : type
    },
    requestHookSubclass: {
        name: 'RequestHook subclass',
        predicate: value => value instanceof hook_1.default && value.constructor && value.constructor !== hook_1.default
    },
    clientScriptInitializer: {
        name: 'client script initializer',
        predicate: obj => hasSomePropInObject(obj, ['path', 'content', 'module'])
    },
    testTimeouts: {
        name: 'test timeouts initializer',
        predicate: obj => hasSomePropInObject(obj, Object.keys(test_timeout_1.default))
    }
};
function assertType(types, callsiteName, what, value) {
    types = lodash_1.castArray(types);
    let pass = false;
    const actualType = typeof value;
    let actualMsg = actualType;
    let expectedTypeMsg = '';
    const last = types.length - 1;
    types.forEach((type, i) => {
        pass = pass || type.predicate(value, actualType);
        if (type.getActualValueMsg)
            actualMsg = type.getActualValueMsg(value, actualType);
        if (i === 0)
            expectedTypeMsg += type.name;
        else
            expectedTypeMsg += (i === last ? ' or ' + getIndefiniteArticle(type.name) + ' ' : ', ') + type.name;
    });
    if (!pass) {
        throw callsiteName ?
            new _1.APIError(callsiteName, types_1.RUNTIME_ERRORS.invalidValueType, what, expectedTypeMsg, actualMsg) :
            new _1.GeneralError(types_1.RUNTIME_ERRORS.invalidValueType, what, expectedTypeMsg, actualMsg);
    }
}
exports.assertType = assertType;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZS1hc3NlcnRpb25zLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2Vycm9ycy9ydW50aW1lL3R5cGUtYXNzZXJ0aW9ucy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxtQ0FLZ0I7QUFFaEIseUJBQTRDO0FBQzVDLG9DQUEwQztBQUMxQyx3RUFBdUQ7QUFDdkQsb0ZBQTJEO0FBRTNELE1BQU0sbUJBQW1CLEdBQUcsV0FBVyxDQUFDO0FBRXhDLFNBQVMsb0JBQW9CLENBQUUsSUFBSTtJQUMvQixPQUFPLG1CQUFtQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUM7QUFDdkQsQ0FBQztBQUVELFNBQVMsa0JBQWtCLENBQUUsS0FBSztJQUM5QixPQUFPLGlCQUFjLENBQUMsS0FBSyxDQUFDLElBQUksS0FBSyxJQUFJLENBQUMsQ0FBQztBQUMvQyxDQUFDO0FBRUQsU0FBUywyQkFBMkIsQ0FBRSxLQUFLLEVBQUUsSUFBSTtJQUM3QyxJQUFJLElBQUksS0FBSyxRQUFRO1FBQ2pCLE9BQU8sSUFBSSxDQUFDO0lBRWhCLElBQUksTUFBTSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUM7UUFDbkIsT0FBTyxHQUFHLENBQUM7SUFFZixJQUFJLENBQUMsaUJBQWMsQ0FBQyxLQUFLLENBQUM7UUFDdEIsT0FBTyxRQUFRLENBQUM7SUFFcEIsT0FBTyxLQUFLLENBQUM7QUFDakIsQ0FBQztBQUVELFNBQVMsbUJBQW1CLENBQUUsR0FBRyxFQUFFLEtBQUs7SUFDcEMsT0FBTyxDQUFDLENBQUMsR0FBRztRQUNSLE9BQU8sR0FBRyxLQUFLLFFBQVE7UUFDdkIsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksSUFBSSxHQUFHLENBQUMsQ0FBQztBQUN4QyxDQUFDO0FBRVksUUFBQSxFQUFFLEdBQUc7SUFDZCxNQUFN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dCI6WyJpbXBvcnQge1xuICAgIGlzRmluaXRlIGFzIGlzRmluaXRlTnVtYmVyLFxuICAgIGlzUmVnRXhwLFxuICAgIGlzTmlsIGFzIGlzTnVsbE9yVW5kZWZpbmVkLFxuICAgIGNhc3RBcnJheVxufSBmcm9tICdsb2Rhc2gnO1xuXG5pbXBvcnQgeyBBUElFcnJvciwgR2VuZXJhbEVycm9yIH0gZnJvbSAnLi8nO1xuaW1wb3J0IHsgUlVOVElNRV9FUlJPUlMgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgUmVxdWVzdEhvb2sgZnJvbSAnLi4vLi4vYXBpL3JlcXVlc3QtaG9va3MvaG9vayc7XG5pbXBvcnQgVGVzdFRpbWVvdXQgZnJvbSAnLi4vLi4vYXBpL3N0cnVjdHVyZS90ZXN0LXRpbWVvdXQnO1xuXG5jb25zdCBTVEFSVF9GUk9NX1ZPV0VMX1JFID0gL15bYWVpb3VdL2k7XG5cbmZ1bmN0aW9uIGdldEluZGVmaW5pdGVBcnRpY2xlICh0ZXh0KSB7XG4gICAgcmV0dXJuIFNUQVJUX0ZST01fVk9XRUxfUkUudGVzdCh0ZXh0KSA/ICdhbicgOiAnYSc7XG59XG5cbmZ1bmN0aW9uIGlzTm9uTmVnYXRpdmVWYWx1ZSAodmFsdWUpIHtcbiAgICByZXR1cm4gaXNGaW5pdGVOdW1iZXIodmFsdWUpICYmIHZhbHVlID49IDA7XG59XG5cbmZ1bmN0aW9uIGdldE51bWJlclR5cGVBY3R1YWxWYWx1ZU1zZyAodmFsdWUsIHR5cGUpIHtcbiAgICBpZiAodHlwZSAhPT0gJ251bWJlcicpXG4gICAgICAgIHJldHVybiB0eXBlO1xuXG4gICAgaWYgKE51bWJlci5pc05hTih2YWx1ZSkpXG4gICAgICAgIHJldHVybiBOYU47XG5cbiAgICBpZiAoIWlzRmluaXRlTnVtYmVyKHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuXG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBoYXNTb21lUHJvcEluT2JqZWN0IChvYmosIHByb3BzKSB7XG4gICAgcmV0dXJuICEhb2JqICYmXG4gICAgICAgIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmXG4gICAgICAgIHByb3BzLnNvbWUocHJvcCA9PiBwcm9wIGluIG9iaik7XG59XG5cbmV4cG9ydCBjb25zdCBpcyA9IHtcbiAgICBudW1iZXI6IHtcbiAgICAgICAgbmFtZTogICAgICAgICAgICAgICdudW1iZXInLFxuICAgICAgICBwcmVkaWNhdGU6ICAgICAgICAgaXNGaW5pdGVOdW1iZXIsXG4gICAgICAgIGdldEFjdHVhbFZhbHVlTXNnOiBnZXROdW1iZXJUeXBlQWN0dWFsVmFsdWVNc2dcbiAgICB9LFxuXG4gICAgbm9uTmVnYXRpdmVOdW1iZXI6IHtcbiAgICAgICAgbmFtZTogICAgICAgICAgICAgICdub24tbmVnYXRpdmUgbnVtYmVyJyxcbiAgICAgICAgcHJlZGljYXRlOiAgICAgICAgIGlzTm9uTmVnYXRpdmVWYWx1ZSxcbiAgICAgICAgZ2V0QWN0dWFsVmFsdWVNc2c6IGdldE51bWJlclR5cGVBY3R1YWxWYWx1ZU1zZ1xuICAgIH0sXG5cbiAgICBub25OZWdhdGl2ZU51bWJlclN0cmluZzoge1xuICAgICAgICBuYW1lOiAgICAgICdub24tbmVnYXRpdmUgbnVtYmVyJyxcbiAgICAgICAgcHJlZGljYXRlOiB2YWx1ZSA9PiBpc05vbk5lZ2F0aXZlVmFsdWUocGFyc2VJbnQodmFsdWUsIDEwKSksXG5cbiAgICAgICAgZ2V0QWN0dWFsVmFsdWVNc2c6IHZhbHVlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG51bWJlciA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XG5cbiAgICAgICAgICAgIHJldHVybiBpc05hTihudW1iZXIpID8gSlNPTi5zdHJpbmdpZnkodmFsdWUpIDogbnVtYmVyO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGJvb2xlYW46IHtcbiAgICAgICAgbmFtZTogICAgICAnYm9vbGVhbicsXG4gICAgICAgIHByZWRpY2F0ZTogKHZhbHVlLCB0eXBlKSA9PiB0eXBlID09PSAnYm9vbGVhbidcbiAgICB9LFxuXG4gICAgc3RyaW5nOiB7XG4gICAgICAgIG5hbWU6ICAgICAgJ3N0cmluZycsXG4gICAgICAgIHByZWRpY2F0ZTogKHZhbHVlLCB0eXBlKSA9PiB0eXBlID09PSAnc3RyaW5nJ1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbjoge1xuICAgICAgICBuYW1lOiAgICAgICdmdW5jdGlvbicsXG4gICAgICAgIHByZWRpY2F0ZTogKHZhbHVlLCB0eXBlKSA9PiB0eXBlID09PSAnZnVuY3Rpb24nXG4gICAgfSxcblxuICAgIHJlZ0V4cDoge1xuICAgICAgICBuYW1lOiAgICAgICdyZWd1bGFyIGV4cHJlc3Npb24nLFxuICAgICAgICBwcmVkaWNhdGU6IGlzUmVnRXhwXG4gICAgfSxcblxuICAgIGFycmF5OiB7XG4gICAgICAgIG5hbWU6ICAgICAgJ2FycmF5JyxcbiAgICAgICAgcHJlZGljYXRlOiB2YWx1ZSA9PiBBcnJheS5pc0FycmF5KHZhbHVlKVxuICAgIH0sXG5cbiAgICBub25OdWxsT2JqZWN0OiB7XG4gICAgICAgIG5hbWU6ICAgICAgICAgICAgICAnbm9uLW51bGwgb2JqZWN0JyxcbiAgICAgICAgcHJlZGljYXRlOiAgICAgICAgICh2YWx1ZSwgdHlwZSkgPT4gdHlwZSA9PT0gJ29iamVjdCcgJiYgIWlzTnVsbE9yVW5kZWZpbmVkKHZhbHVlKSxcbiAgICAgICAgZ2V0QWN0dWFsVmFsdWVNc2c6ICh2YWx1ZSwgdHlwZSkgPT4gaXNOdWxsT3JVbmRlZmluZWQodmFsdWUpID8gU3RyaW5nKHZhbHVlKSA6IHR5cGVcbiAgICB9LFxuXG4gICAgcmVxdWVzdEhvb2tTdWJjbGFzczoge1xuICAgICAgICBuYW1lOiAgICAgICdSZXF1ZXN0SG9vayBzdWJjbGFzcycsXG4gICAgICAgIHByZWRpY2F0ZTogdmFsdWUgPT4gdmFsdWUgaW5zdGFuY2VvZiBSZXF1ZXN0SG9vayAmJiB2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3RvciAhPT0gUmVxdWVzdEhvb2tcbiAgICB9LFxuXG4gICAgY2xpZW50U2NyaXB0SW5pdGlhbGl6ZXI6IHtcbiAgICAgICAgbmFtZTogICAgICAnY2xpZW50IHNjcmlwdCBpbml0aWFsaXplcicsXG4gICAgICAgIHByZWRpY2F0ZTogb2JqID0+IGhhc1NvbWVQcm9wSW5PYmplY3Qob2JqLCBbJ3BhdGgnLCAnY29udGVudCcsICdtb2R1bGUnXSlcbiAgICB9LFxuXG4gICAgdGVzdFRpbWVvdXRzOiB7XG4gICAgICAgIG5hbWU6ICAgICAgJ3Rlc3QgdGltZW91dHMgaW5pdGlhbGl6ZXInLFxuICAgICAgICBwcmVkaWNhdGU6IG9iaiA9PiBoYXNTb21lUHJvcEluT2JqZWN0KG9iaiwgT2JqZWN0LmtleXMoVGVzdFRpbWVvdXQpKVxuICAgIH1cbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRUeXBlICh0eXBlcywgY2FsbHNpdGVOYW1lLCB3aGF0LCB2YWx1ZSkge1xuICAgIHR5cGVzID0gY2FzdEFycmF5KHR5cGVzKTtcblxuICAgIGxldCBwYXNzICAgICAgICAgICAgPSBmYWxzZTtcbiAgICBjb25zdCBhY3R1YWxUeXBlICAgID0gdHlwZW9mIHZhbHVlO1xuICAgIGxldCBhY3R1YWxNc2cgICAgICAgPSBhY3R1YWxUeXBlO1xuICAgIGxldCBleHBlY3RlZFR5cGVNc2cgPSAnJztcbiAgICBjb25zdCBsYXN0ICAgICAgICAgICAgPSB0eXBlcy5sZW5ndGggLSAxO1xuXG4gICAgdHlwZXMuZm9yRWFjaCgodHlwZSwgaSkgPT4ge1xuICAgICAgICBwYXNzID0gcGFzcyB8fCB0eXBlLnByZWRpY2F0ZSh2YWx1ZSwgYWN0dWFsVHlwZSk7XG5cbiAgICAgICAgaWYgKHR5cGUuZ2V0QWN0dWFsVmFsdWVNc2cpXG4gICAgICAgICAgICBhY3R1YWxNc2cgPSB0eXBlLmdldEFjdHVhbFZhbHVlTXNnKHZhbHVlLCBhY3R1YWxUeXBlKTtcblxuICAgICAgICBpZiAoaSA9PT0gMClcbiAgICAgICAgICAgIGV4cGVjdGVkVHlwZU1zZyArPSB0eXBlLm5hbWU7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGV4cGVjdGVkVHlwZU1zZyArPSAoaSA9PT0gbGFzdCA/ICcgb3IgJyArIGdldEluZGVmaW5pdGVBcnRpY2xlKHR5cGUubmFtZSkgKyAnICcgOiAnLCAnKSArIHR5cGUubmFtZTtcbiAgICB9KTtcblxuICAgIGlmICghcGFzcykge1xuICAgICAgICB0aHJvdyBjYWxsc2l0ZU5hbWUgP1xuICAgICAgICAgICAgbmV3IEFQSUVycm9yKGNhbGxzaXRlTmFtZSwgUlVOVElNRV9FUlJPUlMuaW52YWxpZFZhbHVlVHlwZSwgd2hhdCwgZXhwZWN0ZWRUeXBlTXNnLCBhY3R1YWxNc2cpIDpcbiAgICAgICAgICAgIG5ldyBHZW5lcmFsRXJyb3IoUlVOVElNRV9FUlJPUlMuaW52YWxpZFZhbHVlVHlwZSwgd2hhdCwgZXhwZWN0ZWRUeXBlTXNnLCBhY3R1YWxNc2cpO1xuICAgIH1cbn1cbiJdfQ==