"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const hook_1 = __importDefault(require("../hook"));
const testcafe_hammerhead_1 = require("testcafe-hammerhead");
const runtime_1 = require("../../../errors/runtime");
const types_1 = require("../../../errors/types");
const warning_message_1 = __importDefault(require("../../../notifications/warning-message"));
class RequestMock extends hook_1.default {
    constructor() {
        super([]);
        this._pendingRequestFilterRuleInit = null;
        this.mocks = new Map();
    }
    async onRequest(event) {
        const mock = this.mocks.get(event.requestFilterRule.id);
        await event.setMock(mock);
    }
    async onResponse(event) {
        var _a;
        if (event.isSameOriginPolicyFailed)
            (_a = this._warningLog) === null || _a === void 0 ? void 0 : _a.addWarning(warning_message_1.default.requestMockCORSValidationFailed, RequestMock.name, event.requestFilterRule);
    }
    // API
    onRequestTo(requestFilterRuleInit) {
        if (this._pendingRequestFilterRuleInit)
            throw new runtime_1.APIError('onRequestTo', types_1.RUNTIME_ERRORS.requestHookConfigureAPIError, RequestMock.name, "The 'respond' method was not called after 'onRequestTo'. You must call the 'respond' method to provide the mocked response.");
        this._pendingRequestFilterRuleInit = requestFilterRuleInit;
        return this;
    }
    respond(body, statusCode, headers) {
        if (!this._pendingRequestFilterRuleInit)
            throw new runtime_1.APIError('respond', types_1.RUNTIME_ERRORS.requestHookConfigureAPIError, RequestMock.name, "The 'onRequestTo' method was not called before 'respond'. You must call the 'onRequestTo' method to provide the URL requests to which are mocked.");
        const mock = new testcafe_hammerhead_1.ResponseMock(body, statusCode, headers);
        const rule = new testcafe_hammerhead_1.RequestFilterRule(this._pendingRequestFilterRuleInit);
        this._requestFilterRules.push(rule);
        this.mocks.set(rule.id, mock);
        this._pendingRequestFilterRuleInit = null;
        return this;
    }
}
exports.default = RequestMock;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvYXBpL3JlcXVlc3QtaG9va3MvcmVxdWVzdC1tb2NrL2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsbURBQWtDO0FBRWxDLDZEQU02QjtBQUU3QixxREFBbUQ7QUFDbkQsaURBQXVEO0FBQ3ZELDZGQUFxRTtBQUdyRSxNQUFxQixXQUFZLFNBQVEsY0FBVztJQUloRDtRQUNJLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUVWLElBQUksQ0FBQyw2QkFBNkIsR0FBRyxJQUFJLENBQUM7UUFDMUMsSUFBSSxDQUFDLEtBQUssR0FBMkIsSUFBSSxHQUFHLEVBQUUsQ0FBQztJQUNuRCxDQUFDO0lBRU0sS0FBSyxDQUFDLFNBQVMsQ0FBRSxLQUFtQjtRQUN2QyxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsaUJBQWlCLENBQUMsRUFBRSxDQUFpQixDQUFDO1FBRXhFLE1BQU0sS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUM5QixDQUFDO0lBRU0sS0FBSyxDQUFDLFVBQVUsQ0FBRSxLQUFvQjs7UUFDekMsSUFBSSxLQUFLLENBQUMsd0JBQXdCO1lBQzlCLE1BQUEsSUFBSSxDQUFDLFdBQVcsMENBQUUsVUFBVSxDQUFDLHlCQUFlLENBQUMsK0JBQStCLEVBQUUsV0FBVyxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsaUJBQWlCLEVBQUU7SUFDakksQ0FBQztJQUVELE1BQU07SUFDQyxXQUFXLENBQUUscUJBQTRDO1FBQzVELElBQUksSUFBSSxDQUFDLDZCQUE2QjtZQUNsQyxNQUFNLElBQUksa0JBQVEsQ0FBQyxhQUFhLEVBQUUsc0JBQWMsQ0FBQyw0QkFBNEIsRUFBRSxXQUFXLENBQUMsSUFBSSxFQUFFLDZIQUE2SCxDQUFDLENBQUM7UUFFcE8sSUFBSSxDQUFDLDZCQUE2QixHQUFHLHFCQUFxQixDQUFDO1FBRTNELE9BQU8sSUFBSSxDQUFDO0lBQ2hCLENBQUM7SUFFTSxPQUFPLENBQUUsSUFBdUIsRUFBRSxVQUFtQixFQUFFLE9BQWdCO1FBQzFFLElBQUksQ0FBQyxJQUFJLENBQUMsNkJBQTZCO1lBQ25DLE1BQU0sSUFBSSxrQkFBUSxDQUFDLFNBQVMsRUFBRSxzQkFBYyxDQUFDLDRCQUE0QixFQUFFLFdBQVcsQ0FBQyxJQUFJLEVBQUUsbUpBQW1KLENBQUMsQ0FBQztRQUV0UCxNQUFNLElBQUksR0FBRyxJQUFJLGtDQUFZLENBQUMsSUFBSSxFQUFFLFVBQVUsRUFBRSxPQUFPLENBQUMsQ0FBQztRQUN6RCxNQUFNLElBQUksR0FBRyxJQUFJLHVDQUFpQixDQUFDLElBQUksQ0FBQyw2QkFBNkIsQ0FBQyxDQUFDO1FBRXZFLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDcEMsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxJQUFJLENBQUMsQ0FBQztRQUU5QixJQUFJLENBQUMsNkJBQTZCLEdBQUcsSUFBSSxDQUFDO1FBRTFDLE9BQU8sSUFBSSxDQUFDO0lBQ2hCLENBQUM7Q0FDSjtBQTlDRCw4QkE4Q0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVxdWVzdEhvb2sgZnJvbSAnLi4vaG9vayc7XG5cbmltcG9ydCB7XG4gICAgUmVzcG9uc2VNb2NrLFxuICAgIFJlcXVlc3RFdmVudCxcbiAgICBSZXNwb25zZUV2ZW50LFxuICAgIFJlcXVlc3RGaWx0ZXJSdWxlSW5pdCxcbiAgICBSZXF1ZXN0RmlsdGVyUnVsZVxufSBmcm9tICd0ZXN0Y2FmZS1oYW1tZXJoZWFkJztcblxuaW1wb3J0IHsgQVBJRXJyb3IgfSBmcm9tICcuLi8uLi8uLi9lcnJvcnMvcnVudGltZSc7XG5pbXBvcnQgeyBSVU5USU1FX0VSUk9SUyB9IGZyb20gJy4uLy4uLy4uL2Vycm9ycy90eXBlcyc7XG5pbXBvcnQgV0FSTklOR19NRVNTQUdFIGZyb20gJy4uLy4uLy4uL25vdGlmaWNhdGlvbnMvd2FybmluZy1tZXNzYWdlJztcblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZXF1ZXN0TW9jayBleHRlbmRzIFJlcXVlc3RIb29rIHtcbiAgICBwcml2YXRlIF9wZW5kaW5nUmVxdWVzdEZpbHRlclJ1bGVJbml0OiBudWxsIHwgUmVxdWVzdEZpbHRlclJ1bGVJbml0O1xuICAgIHB1YmxpYyBtb2NrczogTWFwPHN0cmluZywgUmVzcG9uc2VNb2NrPjtcblxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvciAoKSB7XG4gICAgICAgIHN1cGVyKFtdKTtcblxuICAgICAgICB0aGlzLl9wZW5kaW5nUmVxdWVzdEZpbHRlclJ1bGVJbml0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5tb2NrcyAgICAgICAgICAgICAgICAgICAgICAgICA9IG5ldyBNYXAoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgb25SZXF1ZXN0IChldmVudDogUmVxdWVzdEV2ZW50KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IG1vY2sgPSB0aGlzLm1vY2tzLmdldChldmVudC5yZXF1ZXN0RmlsdGVyUnVsZS5pZCkgYXMgUmVzcG9uc2VNb2NrO1xuXG4gICAgICAgIGF3YWl0IGV2ZW50LnNldE1vY2sobW9jayk7XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIG9uUmVzcG9uc2UgKGV2ZW50OiBSZXNwb25zZUV2ZW50KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGlmIChldmVudC5pc1NhbWVPcmlnaW5Qb2xpY3lGYWlsZWQpXG4gICAgICAgICAgICB0aGlzLl93YXJuaW5nTG9nPy5hZGRXYXJuaW5nKFdBUk5JTkdfTUVTU0FHRS5yZXF1ZXN0TW9ja0NPUlNWYWxpZGF0aW9uRmFpbGVkLCBSZXF1ZXN0TW9jay5uYW1lLCBldmVudC5yZXF1ZXN0RmlsdGVyUnVsZSk7XG4gICAgfVxuXG4gICAgLy8gQVBJXG4gICAgcHVibGljIG9uUmVxdWVzdFRvIChyZXF1ZXN0RmlsdGVyUnVsZUluaXQ6IFJlcXVlc3RGaWx0ZXJSdWxlSW5pdCk6IFJlcXVlc3RNb2NrIHtcbiAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdSZXF1ZXN0RmlsdGVyUnVsZUluaXQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgQVBJRXJyb3IoJ29uUmVxdWVzdFRvJywgUlVOVElNRV9FUlJPUlMucmVxdWVzdEhvb2tDb25maWd1cmVBUElFcnJvciwgUmVxdWVzdE1vY2submFtZSwgXCJUaGUgJ3Jlc3BvbmQnIG1ldGhvZCB3YXMgbm90IGNhbGxlZCBhZnRlciAnb25SZXF1ZXN0VG8nLiBZb3UgbXVzdCBjYWxsIHRoZSAncmVzcG9uZCcgbWV0aG9kIHRvIHByb3ZpZGUgdGhlIG1vY2tlZCByZXNwb25zZS5cIik7XG5cbiAgICAgICAgdGhpcy5fcGVuZGluZ1JlcXVlc3RGaWx0ZXJSdWxlSW5pdCA9IHJlcXVlc3RGaWx0ZXJSdWxlSW5pdDtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBwdWJsaWMgcmVzcG9uZCAoYm9keTogc3RyaW5nIHwgRnVuY3Rpb24sIHN0YXR1c0NvZGU/OiBudW1iZXIsIGhlYWRlcnM/OiBvYmplY3QpOiBSZXF1ZXN0TW9jayB7XG4gICAgICAgIGlmICghdGhpcy5fcGVuZGluZ1JlcXVlc3RGaWx0ZXJSdWxlSW5pdClcbiAgICAgICAgICAgIHRocm93IG5ldyBBUElFcnJvcigncmVzcG9uZCcsIFJVTlRJTUVfRVJST1JTLnJlcXVlc3RIb29rQ29uZmlndXJlQVBJRXJyb3IsIFJlcXVlc3RNb2NrLm5hbWUsIFwiVGhlICdvblJlcXVlc3RUbycgbWV0aG9kIHdhcyBub3QgY2FsbGVkIGJlZm9yZSAncmVzcG9uZCcuIFlvdSBtdXN0IGNhbGwgdGhlICdvblJlcXVlc3RUbycgbWV0aG9kIHRvIHByb3ZpZGUgdGhlIFVSTCByZXF1ZXN0cyB0byB3aGljaCBhcmUgbW9ja2VkLlwiKTtcblxuICAgICAgICBjb25zdCBtb2NrID0gbmV3IFJlc3BvbnNlTW9jayhib2R5LCBzdGF0dXNDb2RlLCBoZWFkZXJzKTtcbiAgICAgICAgY29uc3QgcnVsZSA9IG5ldyBSZXF1ZXN0RmlsdGVyUnVsZSh0aGlzLl9wZW5kaW5nUmVxdWVzdEZpbHRlclJ1bGVJbml0KTtcblxuICAgICAgICB0aGlzLl9yZXF1ZXN0RmlsdGVyUnVsZXMucHVzaChydWxlKTtcbiAgICAgICAgdGhpcy5tb2Nrcy5zZXQocnVsZS5pZCwgbW9jayk7XG5cbiAgICAgICAgdGhpcy5fcGVuZGluZ1JlcXVlc3RGaWx0ZXJSdWxlSW5pdCA9IG51bGw7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuIl19