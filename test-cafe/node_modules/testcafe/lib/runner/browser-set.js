"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const time_limit_promise_1 = __importDefault(require("time-limit-promise"));
const promisify_event_1 = __importDefault(require("promisify-event"));
const lodash_1 = require("lodash");
const runtime_1 = require("../errors/runtime");
const types_1 = require("../errors/types");
const status_1 = __importDefault(require("../browser/connection/status"));
const get_hints_1 = __importDefault(require("../browser/connection/get-hints"));
const string_1 = require("../utils/string");
const RELEASE_TIMEOUT = 10000;
class BrowserSet extends events_1.EventEmitter {
    constructor(browserConnectionGroups, options) {
        super();
        this._pendingReleases = [];
        this.browserConnectionGroups = browserConnectionGroups;
        this._browserConnections = lodash_1.flatten(browserConnectionGroups);
        this._options = options;
        this._browserErrorHandler = (error) => this.emit('error', error);
        this._browserConnections.forEach(bc => bc.on('error', this._browserErrorHandler));
        // NOTE: We're setting an empty error handler, because Node kills the process on an 'error' event
        // if there is no handler. See: https://nodejs.org/api/events.html#events_class_events_eventemitter
        this.on('error', lodash_1.noop);
    }
    static async _waitIdle(bc) {
        if (bc.idle || !bc.isReady())
            return;
        await promisify_event_1.default(bc, 'idle');
    }
    static async _closeConnection(bc) {
        if (bc.status === status_1.default.closed || bc.status === status_1.default.closing)
            return;
        await bc.close();
    }
    async _waitConnectionOpened(bc) {
        const openedTimeout = this._options.browserInitTimeout || await bc.getDefaultBrowserInitTimeout();
        const timeoutErr = new runtime_1.GeneralError(types_1.RUNTIME_ERRORS.cannotEstablishBrowserConnection);
        const openedOrError = Promise.race([
            promisify_event_1.default(this, 'error'),
            promisify_event_1.default(bc, 'opened')
        ]);
        return time_limit_promise_1.default(openedOrError, openedTimeout, { rejectWith: timeoutErr });
    }
    async _waitConnectionsOpened() {
        return Promise.all(this._browserConnections
            .filter(bc => bc.status !== status_1.default.opened)
            .map(notOpenedConnection => this._waitConnectionOpened(notOpenedConnection)));
    }
    _checkForDisconnections() {
        const disconnectedUserAgents = this._browserConnections
            .filter(bc => bc.status === status_1.default.closed)
            .map(bc => bc.userAgent);
        if (disconnectedUserAgents.length)
            throw new runtime_1.GeneralError(types_1.RUNTIME_ERRORS.cannotRunAgainstDisconnectedBrowsers, disconnectedUserAgents.join(', '));
    }
    async prepareConnections() {
        await this._checkForDisconnections();
        await this._waitConnectionsOpened();
    }
    // NOTE: creates and prepares BrowserSet instance with given browser connections
    static async from(browserConnections, opts) {
        const browserSet = new BrowserSet(browserConnections, opts);
        try {
            const prepareConnections = browserSet.prepareConnections();
            const browserSetError = promisify_event_1.default(browserSet, 'error');
            await Promise.race([prepareConnections, browserSetError]);
            return browserSet;
        }
        catch (e) {
            const finalError = e.code === types_1.RUNTIME_ERRORS.cannotEstablishBrowserConnection
                ? browserSet.createBrowserConnectionError(e)
                : e;
            await browserSet.dispose();
            throw finalError;
        }
    }
    createBrowserConnectionError(error) {
        const notOpenedConnections = this._browserConnections.filter(bc => bc.status !== status_1.default.opened);
        const numOfAllConnections = this._browserConnections.length;
        const numOfNotOpenedConnections = notOpenedConnections.length;
        const listOfNotOpenedConnections = string_1.createList(notOpenedConnections.map(bc => bc.browserInfo.alias));
        const listOfHints = string_1.createList(get_hints_1.default(this._browserConnections, this._options));
        return new runtime_1.BrowserConnectionError(error.message, numOfNotOpenedConnections, numOfAllConnections, listOfNotOpenedConnections, listOfHints);
    }
    releaseConnection(bc) {
        if (!this._browserConnections.includes(bc))
            return Promise.resolve();
        lodash_1.pull(this._browserConnections, bc);
        bc.removeListener('error', this._browserErrorHandler);
        const appropriateStateSwitch = bc.permanent ?
            BrowserSet._waitIdle(bc) :
            BrowserSet._closeConnection(bc);
        const release = time_limit_promise_1.default(appropriateStateSwitch, RELEASE_TIMEOUT)
            .then(() => lodash_1.pull(this._pendingReleases, release));
        this._pendingReleases.push(release);
        return release;
    }
    async dispose() {
        // NOTE: When browserConnection is cancelled, it is removed from
        // the this.connections array, which leads to shifting indexes
        // towards the beginning. So, we must copy the array in order to iterate it,
        // or we can perform iteration from the end to the beginning.
        this._browserConnections.reduceRight((_, bc) => {
            this.releaseConnection(bc);
            return bc;
        }, {});
        await Promise.all(this._pendingReleases);
    }
}
exports.default = BrowserSet;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnJvd3Nlci1zZXQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvcnVubmVyL2Jyb3dzZXItc2V0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsbUNBQXNDO0FBQ3RDLDRFQUF1RDtBQUN2RCxzRUFBNkM7QUFDN0MsbUNBSWdCO0FBRWhCLCtDQUF5RTtBQUN6RSwyQ0FBaUQ7QUFFakQsMEVBQW1FO0FBRW5FLGdGQUF3RTtBQUN4RSw0Q0FBNkM7QUFFN0MsTUFBTSxlQUFlLEdBQUcsS0FBSyxDQUFDO0FBRTlCLE1BQXFCLFVBQVcsU0FBUSxxQkFBWTtJQU9oRCxZQUFvQix1QkFBOEMsRUFBRSxPQUEwQjtRQUMxRixLQUFLLEVBQUUsQ0FBQztRQUVSLElBQUksQ0FBQyxnQkFBZ0IsR0FBVyxFQUFFLENBQUM7UUFDbkMsSUFBSSxDQUFDLHVCQUF1QixHQUFJLHVCQUF1QixDQUFDO1FBQ3hELElBQUksQ0FBQyxtQkFBbUIsR0FBUSxnQkFBTyxDQUFDLHVCQUF1QixDQUFDLENBQUM7UUFDakUsSUFBSSxDQUFDLFFBQVEsR0FBbUIsT0FBTyxDQUFDO1FBRXhDLElBQUksQ0FBQyxvQkFBb0IsR0FBRyxDQUFDLEtBQVksRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFFeEUsSUFBSSxDQUFDLG1CQUFtQixDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDLENBQUM7UUFFbEYsaUdBQWlHO1FBQ2pHLG1HQUFtRztRQUNuRyxJQUFJLENBQUMsRUFBRSxDQUFDLE9BQU8sRUFBRSxhQUFJLENBQUMsQ0FBQztJQUMzQixDQUFDO0lBRU8sTUFBTSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUUsRUFBcUI7UUFDakQsSUFBSSxFQUFFLENBQUMsSUFBSSxJQUFJ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LEVBQUUsSUFBSSxDQUFDLG9CQUFvQixDQUFDLENBQUM7UUFFdEQsTUFBTSxzQkFBc0IsR0FBRyxFQUFFLENBQUMsU0FBUyxDQUFDLENBQUM7WUFDekMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBQzFCLFVBQVUsQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUVwQyxNQUFNLE9BQU8sR0FBRyw0QkFBcUIsQ0FBQyxzQkFBc0IsRUFBRSxlQUFlLENBQUM7YUFDekUsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDLGFBQU0sQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsT0FBTyxDQUFDLENBQWtCLENBQUM7UUFFekUsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUVwQyxPQUFPLE9BQU8sQ0FBQztJQUNuQixDQUFDO0lBRU0sS0FBSyxDQUFDLE9BQU87UUFDaEIsZ0VBQWdFO1FBQ2hFLDhEQUE4RDtRQUM5RCw0RUFBNEU7UUFDNUUsNkRBQTZEO1FBQzdELElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUU7WUFDM0MsSUFBSSxDQUFDLGlCQUFpQixDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBRTNCLE9BQU8sRUFBRSxDQUFDO1FBQ2QsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBRVAsTUFBTSxPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO0lBQzdDLENBQUM7Q0FDSjtBQWpKRCw2QkFpSkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudHMnO1xuaW1wb3J0IGdldFRpbWVMaW1pdGVkUHJvbWlzZSBmcm9tICd0aW1lLWxpbWl0LXByb21pc2UnO1xuaW1wb3J0IHByb21pc2lmeUV2ZW50IGZyb20gJ3Byb21pc2lmeS1ldmVudCc7XG5pbXBvcnQge1xuICAgIGZsYXR0ZW4sXG4gICAgbm9vcCxcbiAgICBwdWxsIGFzIHJlbW92ZVxufSBmcm9tICdsb2Rhc2gnO1xuXG5pbXBvcnQgeyBCcm93c2VyQ29ubmVjdGlvbkVycm9yLCBHZW5lcmFsRXJyb3IgfSBmcm9tICcuLi9lcnJvcnMvcnVudGltZSc7XG5pbXBvcnQgeyBSVU5USU1FX0VSUk9SUyB9IGZyb20gJy4uL2Vycm9ycy90eXBlcyc7XG5pbXBvcnQgQnJvd3NlckNvbm5lY3Rpb24gZnJvbSAnLi4vYnJvd3Nlci9jb25uZWN0aW9uJztcbmltcG9ydCBCcm93c2VyQ29ubmVjdGlvblN0YXR1cyBmcm9tICcuLi9icm93c2VyL2Nvbm5lY3Rpb24vc3RhdHVzJztcbmltcG9ydCB7IEJyb3dzZXJTZXRPcHRpb25zIH0gZnJvbSAnLi9pbnRlcmZhY2VzJztcbmltcG9ydCBnZXRCcm93c2VyQ29ubmVjdGlvbkhpbnRzIGZyb20gJy4uL2Jyb3dzZXIvY29ubmVjdGlvbi9nZXQtaGludHMnO1xuaW1wb3J0IHsgY3JlYXRlTGlzdCB9IGZyb20gJy4uL3V0aWxzL3N0cmluZyc7XG5cbmNvbnN0IFJFTEVBU0VfVElNRU9VVCA9IDEwMDAwO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCcm93c2VyU2V0IGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IF9icm93c2VyQ29ubmVjdGlvbnM6IEJyb3dzZXJDb25uZWN0aW9uW107XG4gICAgcHJpdmF0ZSByZWFkb25seSBfYnJvd3NlckVycm9ySGFuZGxlcjogKGVycm9yOiBFcnJvcikgPT4gdm9pZDtcbiAgICBwcml2YXRlIHJlYWRvbmx5IF9wZW5kaW5nUmVsZWFzZXM6IFByb21pc2U8dm9pZD5bXTtcbiAgICBwcml2YXRlIHJlYWRvbmx5IF9vcHRpb25zOiBCcm93c2VyU2V0T3B0aW9ucztcbiAgICBwdWJsaWMgYnJvd3NlckNvbm5lY3Rpb25Hcm91cHM6IEJyb3dzZXJDb25uZWN0aW9uW11bXTtcblxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvciAoYnJvd3NlckNvbm5lY3Rpb25Hcm91cHM6IEJyb3dzZXJDb25uZWN0aW9uW11bXSwgb3B0aW9uczogQnJvd3NlclNldE9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLl9wZW5kaW5nUmVsZWFzZXMgICAgICAgICA9IFtdO1xuICAgICAgICB0aGlzLmJyb3dzZXJDb25uZWN0aW9uR3JvdXBzICA9IGJyb3dzZXJDb25uZWN0aW9uR3JvdXBzO1xuICAgICAgICB0aGlzLl9icm93c2VyQ29ubmVjdGlvbnMgICAgICA9IGZsYXR0ZW4oYnJvd3NlckNvbm5lY3Rpb25Hcm91cHMpO1xuICAgICAgICB0aGlzLl9vcHRpb25zICAgICAgICAgICAgICAgICA9IG9wdGlvbnM7XG5cbiAgICAgICAgdGhpcy5fYnJvd3NlckVycm9ySGFuZGxlciA9IChlcnJvcjogRXJyb3IpID0+IHRoaXMuZW1pdCgnZXJyb3InLCBlcnJvcik7XG5cbiAgICAgICAgdGhpcy5fYnJvd3NlckNvbm5lY3Rpb25zLmZvckVhY2goYmMgPT4gYmMub24oJ2Vycm9yJywgdGhpcy5fYnJvd3NlckVycm9ySGFuZGxlcikpO1xuXG4gICAgICAgIC8vIE5PVEU6IFdlJ3JlIHNldHRpbmcgYW4gZW1wdHkgZXJyb3IgaGFuZGxlciwgYmVjYXVzZSBOb2RlIGtpbGxzIHRoZSBwcm9jZXNzIG9uIGFuICdlcnJvcicgZXZlbnRcbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gaGFuZGxlci4gU2VlOiBodHRwczovL25vZGVqcy5vcmcvYXBpL2V2ZW50cy5odG1sI2V2ZW50c19jbGFzc19ldmVudHNfZXZlbnRlbWl0dGVyXG4gICAgICAgIHRoaXMub24oJ2Vycm9yJywgbm9vcCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgYXN5bmMgX3dhaXRJZGxlIChiYzogQnJvd3NlckNvbm5lY3Rpb24pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgaWYgKGJjLmlkbGUgfHwgIWJjLmlzUmVhZHkoKSlcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBhd2FpdCBwcm9taXNpZnlFdmVudChiYywgJ2lkbGUnKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBhc3luYyBfY2xvc2VDb25uZWN0aW9uIChiYzogQnJvd3NlckNvbm5lY3Rpb24pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgaWYgKGJjLnN0YXR1cyA9PT0gQnJvd3NlckNvbm5lY3Rpb25TdGF0dXMuY2xvc2VkIHx8IGJjLnN0YXR1cyA9PT0gQnJvd3NlckNvbm5lY3Rpb25TdGF0dXMuY2xvc2luZylcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBhd2FpdCBiYy5jbG9zZSgpO1xuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgX3dhaXRDb25uZWN0aW9uT3BlbmVkIChiYzogQnJvd3NlckNvbm5lY3Rpb24pOiBQcm9taXNlPEJyb3dzZXJDb25uZWN0aW9uPiB7XG4gICAgICAgIGNvbnN0IG9wZW5lZFRpbWVvdXQgPSB0aGlzLl9vcHRpb25zLmJyb3dzZXJJbml0VGltZW91dCB8fCBhd2FpdCBiYy5nZXREZWZhdWx0QnJvd3NlckluaXRUaW1lb3V0KCk7XG4gICAgICAgIGNvbnN0IHRpbWVvdXRFcnIgICAgPSBuZXcgR2VuZXJhbEVycm9yKFJVTlRJTUVfRVJST1JTLmNhbm5vdEVzdGFibGlzaEJyb3dzZXJDb25uZWN0aW9uKTtcbiAgICAgICAgY29uc3Qgb3BlbmVkT3JFcnJvciA9IFByb21pc2UucmFjZShbXG4gICAgICAgICAgICBwcm9taXNpZnlFdmVudCh0aGlzLCAnZXJyb3InKSxcbiAgICAgICAgICAgIHByb21pc2lmeUV2ZW50KGJjLCAnb3BlbmVkJylcbiAgICAgICAgXSk7XG5cbiAgICAgICAgcmV0dXJuIGdldFRpbWVMaW1pdGVkUHJvbWlzZShvcGVuZWRPckVycm9yLCBvcGVuZWRUaW1lb3V0LCB7IHJlamVjdFdpdGg6IHRpbWVvdXRFcnIgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhc3luYyBfd2FpdENvbm5lY3Rpb25zT3BlbmVkICgpOiBQcm9taXNlPEJyb3dzZXJDb25uZWN0aW9uW10+IHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgICAgICAgICAgdGhpcy5fYnJvd3NlckNvbm5lY3Rpb25zXG4gICAgICAgICAgICAgICAgLmZpbHRlcihiYyA9PiBiYy5zdGF0dXMgIT09IEJyb3dzZXJDb25uZWN0aW9uU3RhdHVzLm9wZW5lZClcbiAgICAgICAgICAgICAgICAubWFwKG5vdE9wZW5lZENvbm5lY3Rpb24gPT4gdGhpcy5fd2FpdENvbm5lY3Rpb25PcGVuZWQobm90T3BlbmVkQ29ubmVjdGlvbikpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfY2hlY2tGb3JEaXNjb25uZWN0aW9ucyAoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGRpc2Nvbm5lY3RlZFVzZXJBZ2VudHMgPSB0aGlzLl9icm93c2VyQ29ubmVjdGlvbnNcbiAgICAgICAgICAgIC5maWx0ZXIoYmMgPT4gYmMuc3RhdHVzID09PSBCcm93c2VyQ29ubmVjdGlvblN0YXR1cy5jbG9zZWQpXG4gICAgICAgICAgICAubWFwKGJjID0+IGJjLnVzZXJBZ2VudCk7XG5cbiAgICAgICAgaWYgKGRpc2Nvbm5lY3RlZFVzZXJBZ2VudHMubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEdlbmVyYWxFcnJvcihSVU5USU1FX0VSUk9SUy5jYW5ub3RSdW5BZ2FpbnN0RGlzY29ubmVjdGVkQnJvd3NlcnMsIGRpc2Nvbm5lY3RlZFVzZXJBZ2VudHMuam9pbignLCAnKSk7XG4gICAgfVxuXG4gICAgcHVibGljIGFzeW5jIHByZXBhcmVDb25uZWN0aW9ucyAoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGF3YWl0IHRoaXMuX2NoZWNrRm9yRGlzY29ubmVjdGlvbnMoKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fd2FpdENvbm5lY3Rpb25zT3BlbmVkKCk7XG4gICAgfVxuXG4gICAgLy8gTk9URTogY3JlYXRlcyBhbmQgcHJlcGFyZXMgQnJvd3NlclNldCBpbnN0YW5jZSB3aXRoIGdpdmVuIGJyb3dzZXIgY29ubmVjdGlvbnNcbiAgICBwdWJsaWMgc3RhdGljIGFzeW5jIGZyb20gKGJyb3dzZXJDb25uZWN0aW9uczogQnJvd3NlckNvbm5lY3Rpb25bXVtdLCBvcHRzOiBCcm93c2VyU2V0T3B0aW9ucyk6IFByb21pc2U8QnJvd3NlclNldD4ge1xuICAgICAgICBjb25zdCBicm93c2VyU2V0ID0gbmV3IEJyb3dzZXJTZXQoYnJvd3NlckNvbm5lY3Rpb25zLCBvcHRzKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcHJlcGFyZUNvbm5lY3Rpb25zID0gYnJvd3NlclNldC5wcmVwYXJlQ29ubmVjdGlvbnMoKTtcbiAgICAgICAgICAgIGNvbnN0IGJyb3dzZXJTZXRFcnJvciAgICA9IHByb21pc2lmeUV2ZW50KGJyb3dzZXJTZXQsICdlcnJvcicpO1xuXG4gICAgICAgICAgICBhd2FpdCBQcm9taXNlLnJhY2UoWyBwcmVwYXJlQ29ubmVjdGlvbnMsIGJyb3dzZXJTZXRFcnJvciBdKTtcblxuICAgICAgICAgICAgcmV0dXJuIGJyb3dzZXJTZXQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsRXJyb3IgPSBlLmNvZGUgPT09IFJVTlRJTUVfRVJST1JTLmNhbm5vdEVzdGFibGlzaEJyb3dzZXJDb25uZWN0aW9uXG4gICAgICAgICAgICAgICAgPyBicm93c2VyU2V0LmNyZWF0ZUJyb3dzZXJDb25uZWN0aW9uRXJyb3IoZSlcbiAgICAgICAgICAgICAgICA6IGU7XG5cbiAgICAgICAgICAgIGF3YWl0IGJyb3dzZXJTZXQuZGlzcG9zZSgpO1xuXG4gICAgICAgICAgICB0aHJvdyBmaW5hbEVycm9yO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGNyZWF0ZUJyb3dzZXJDb25uZWN0aW9uRXJyb3IgKGVycm9yOiBFcnJvcik6IEJyb3dzZXJDb25uZWN0aW9uRXJyb3Ige1xuICAgICAgICBjb25zdCBub3RPcGVuZWRDb25uZWN0aW9ucyA9IHRoaXMuX2Jyb3dzZXJDb25uZWN0aW9ucy5maWx0ZXIoYmMgPT4gYmMuc3RhdHVzICE9PSBCcm93c2VyQ29ubmVjdGlvblN0YXR1cy5vcGVuZWQpO1xuXG4gICAgICAgIGNvbnN0IG51bU9mQWxsQ29ubmVjdGlvbnMgICAgICAgPSB0aGlzLl9icm93c2VyQ29ubmVjdGlvbnMubGVuZ3RoO1xuICAgICAgICBjb25zdCBudW1PZk5vdE9wZW5lZENvbm5lY3Rpb25zID0gbm90T3BlbmVkQ29ubmVjdGlvbnMubGVuZ3RoO1xuXG4gICAgICAgIGNvbnN0IGxpc3RPZk5vdE9wZW5lZENvbm5lY3Rpb25zID0gY3JlYXRlTGlzdChub3RPcGVuZWRDb25uZWN0aW9ucy5tYXAoYmMgPT4gYmMuYnJvd3NlckluZm8uYWxpYXMpKTtcbiAgICAgICAgY29uc3QgbGlzdE9mSGludHMgICAgICAgICAgICAgICAgPSBjcmVhdGVMaXN0KGdldEJyb3dzZXJDb25uZWN0aW9uSGludHModGhpcy5fYnJvd3NlckNvbm5lY3Rpb25zLCB0aGlzLl9vcHRpb25zKSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBCcm93c2VyQ29ubmVjdGlvbkVycm9yKFxuICAgICAgICAgICAgZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICAgIG51bU9mTm90T3BlbmVkQ29ubmVjdGlvbnMsXG4gICAgICAgICAgICBudW1PZkFsbENvbm5lY3Rpb25zLFxuICAgICAgICAgICAgbGlzdE9mTm90T3BlbmVkQ29ubmVjdGlvbnMsXG4gICAgICAgICAgICBsaXN0T2ZIaW50c1xuICAgICAgICApO1xuICAgIH1cblxuICAgIHB1YmxpYyByZWxlYXNlQ29ubmVjdGlvbiAoYmM6IEJyb3dzZXJDb25uZWN0aW9uKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGlmICghdGhpcy5fYnJvd3NlckNvbm5lY3Rpb25zLmluY2x1ZGVzKGJjKSlcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcblxuICAgICAgICByZW1vdmUodGhpcy5fYnJvd3NlckNvbm5lY3Rpb25zLCBiYyk7XG5cbiAgICAgICAgYmMucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgdGhpcy5fYnJvd3NlckVycm9ySGFuZGxlcik7XG5cbiAgICAgICAgY29uc3QgYXBwcm9wcmlhdGVTdGF0ZVN3aXRjaCA9IGJjLnBlcm1hbmVudCA/XG4gICAgICAgICAgICBCcm93c2VyU2V0Ll93YWl0SWRsZShiYykgOlxuICAgICAgICAgICAgQnJvd3NlclNldC5fY2xvc2VDb25uZWN0aW9uKGJjKTtcblxuICAgICAgICBjb25zdCByZWxlYXNlID0gZ2V0VGltZUxpbWl0ZWRQcm9taXNlKGFwcHJvcHJpYXRlU3RhdGVTd2l0Y2gsIFJFTEVBU0VfVElNRU9VVClcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHJlbW92ZSh0aGlzLl9wZW5kaW5nUmVsZWFzZXMsIHJlbGVhc2UpKSBhcyBQcm9taXNlPHZvaWQ+O1xuXG4gICAgICAgIHRoaXMuX3BlbmRpbmdSZWxlYXNlcy5wdXNoKHJlbGVhc2UpO1xuXG4gICAgICAgIHJldHVybiByZWxlYXNlO1xuICAgIH1cblxuICAgIHB1YmxpYyBhc3luYyBkaXNwb3NlICgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgLy8gTk9URTogV2hlbiBicm93c2VyQ29ubmVjdGlvbiBpcyBjYW5jZWxsZWQsIGl0IGlzIHJlbW92ZWQgZnJvbVxuICAgICAgICAvLyB0aGUgdGhpcy5jb25uZWN0aW9ucyBhcnJheSwgd2hpY2ggbGVhZHMgdG8gc2hpZnRpbmcgaW5kZXhlc1xuICAgICAgICAvLyB0b3dhcmRzIHRoZSBiZWdpbm5pbmcuIFNvLCB3ZSBtdXN0IGNvcHkgdGhlIGFycmF5IGluIG9yZGVyIHRvIGl0ZXJhdGUgaXQsXG4gICAgICAgIC8vIG9yIHdlIGNhbiBwZXJmb3JtIGl0ZXJhdGlvbiBmcm9tIHRoZSBlbmQgdG8gdGhlIGJlZ2lubmluZy5cbiAgICAgICAgdGhpcy5fYnJvd3NlckNvbm5lY3Rpb25zLnJlZHVjZVJpZ2h0KChfLCBiYykgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZWxlYXNlQ29ubmVjdGlvbihiYyk7XG5cbiAgICAgICAgICAgIHJldHVybiBiYztcbiAgICAgICAgfSwge30pO1xuXG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuX3BlbmRpbmdSZWxlYXNlcyk7XG4gICAgfVxufVxuIl19