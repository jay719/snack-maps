"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IPCProxy = void 0;
const error_list_1 = __importDefault(require("../../../errors/error-list"));
const async_event_emitter_1 = __importDefault(require("../../../utils/async-event-emitter"));
const lodash_1 = require("lodash");
const interfaces_1 = require("./interfaces");
const prerender_callsite_1 = __importDefault(require("../../../utils/prerender-callsite"));
class IPCProxy extends async_event_emitter_1.default {
    constructor(transport) {
        super();
        this._requestCounter = 0;
        this._transport = transport;
        this._handlers = {};
        this._transport.read();
        this._transport.on(interfaces_1.IPCTransportEvents.data, rawPacket => this._onRead(rawPacket));
        this.on('request', data => this._onRequest(data));
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    _saveError(error) {
        if (interfaces_1.isTestCafeErrorList(error)) {
            for (const item of error.items) {
                if (item.callsite)
                    item.callsite = prerender_callsite_1.default(item.callsite);
            }
        }
        return error;
    }
    async _onRead(packet) {
        if (packet.type === interfaces_1.IPCPacketType.response)
            this.emit(`response-${packet.id}`, packet);
        else
            this.emit('request', packet);
    }
    async _onRequest(requestPacket) {
        let resultData = null;
        try {
            resultData = { result: await this._handlers[requestPacket.data.name](...requestPacket.data.args) };
        }
        catch (error) {
            resultData = { error: this._saveError(error) };
        }
        const responsePacket = {
            id: requestPacket.id,
            type: interfaces_1.IPCPacketType.response,
            sync: requestPacket.sync,
            data: resultData
        };
        await this._transport.write(responsePacket);
    }
    _createPacket(opts) {
        return {
            id: this._requestCounter++,
            type: interfaces_1.IPCPacketType.request,
            sync: opts.sync,
            data: opts.data
        };
    }
    _createPlainError(errorData) {
        const error = new Error(errorData.message);
        Object.assign(error, errorData);
        return error;
    }
    _createError(errorData) {
        if (interfaces_1.isTestCafeErrorList(errorData)) {
            const errorList = new error_list_1.default();
            errorList.items = errorData.items;
            return errorList;
        }
        return this._createPlainError(errorData);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    register(func, context = null) {
        func = lodash_1.castArray(func);
        func.forEach(fn => {
            if (this._handlers[fn.name])
                return;
            this._handlers[fn.name] = fn.bind(context);
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async call(target, ...args) {
        const name = typeof target === 'string' ? target : target.name;
        const packet = this._createPacket({ data: { name, args }, sync: false });
        const responsePromise = this.once(`response-${packet.id}`);
        await this._transport.write(packet);
        const { data } = await responsePromise;
        if (interfaces_1.isIPCErrorResponse(data))
            throw this._createError(data.error);
        return data.result;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    callSync(target, ...args) {
        const name = typeof target === 'string' ? target : target.name;
        const requestPacket = this._createPacket({ data: { name, args }, sync: true });
        this._transport.writeSync(requestPacket);
        let responsePacket = this._transport.readSync();
        while (responsePacket.id !== requestPacket.id)
            responsePacket = this._transport.readSync();
        const response = responsePacket.data;
        if (interfaces_1.isIPCErrorResponse(response))
            throw this._createError(response.error);
        return response.result;
    }
}
exports.IPCProxy = IPCProxy;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJveHkuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvc2VydmljZXMvdXRpbHMvaXBjL3Byb3h5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLDRFQUEyRDtBQUMzRCw2RkFBOEQ7QUFDOUQsbUNBQW1DO0FBRW5DLDZDQWFzQjtBQUV0QiwyRkFBa0U7QUFRbEUsTUFBYSxRQUFTLFNBQVEsNkJBQVk7SUFLdEMsWUFBb0IsU0FBdUI7UUFDdkMsS0FBSyxFQUFFLENBQUM7UUFKSixvQkFBZSxHQUFXLENBQUMsQ0FBQztRQU1oQyxJQUFJLENBQUMsVUFBVSxHQUFHLFNBQVMsQ0FBQztRQUU1QixJQUFJLENBQUMsU0FBUyxHQUFHLEVBQUUsQ0FBQztRQUVwQixJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksRUFBRSxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLCtCQUFrQixDQUFDLElBQUksRUFBRSxTQUFTLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztRQUNsRixJQUFJLENBQUMsRUFBRSxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztJQUN0RCxDQUFDO0lBRUQsOERBQThEO0lBQ3RELFVBQVUsQ0FBRSxLQUFvQjtRQUNwQyxJQUFJLGdDQUFtQixDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQzVCLEtBQUssTUFBTSxJQUFJLElBQUksS0FBSyxDQUFDLEtBQUssRUFBRTtnQkFDNUIsSUFBSSxJQUFJLENBQUMsUUFBUTtvQkFDYixJQUFJLENBQUMsUUFBUSxHQUFHLDRCQUFpQixDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQzthQUN4RDtTQUNKO1FBRUQsT0FBTyxLQUFLLENBQUM7SUFDakIsQ0FBQztJQUVPLEtBQUssQ0FBQyxPQUFPLENB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SSwrQkFBa0IsQ0FBQyxRQUFRLENBQUM7WUFDNUIsTUFBTSxJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUU1QyxPQUFPLFFBQVEsQ0FBQyxNQUFNLENBQUM7SUFDM0IsQ0FBQztDQUNKO0FBcklELDRCQXFJQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBUZXN0Q2FmZUVycm9yTGlzdCBmcm9tICcuLi8uLi8uLi9lcnJvcnMvZXJyb3ItbGlzdCc7XG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJy4uLy4uLy4uL3V0aWxzL2FzeW5jLWV2ZW50LWVtaXR0ZXInO1xuaW1wb3J0IHsgY2FzdEFycmF5IH0gZnJvbSAnbG9kYXNoJztcblxuaW1wb3J0IHtcbiAgICBFeHRlcm5hbEVycm9yLFxuICAgIGlzVGVzdENhZmVFcnJvckxpc3QsXG5cbiAgICBJUENQYWNrZXQsXG4gICAgSVBDUGFja2V0VHlwZSxcbiAgICBJUENSZXF1ZXN0UGFja2V0LFxuICAgIElQQ1Jlc3BvbnNlUGFja2V0LFxuICAgIElQQ1JlcXVlc3REYXRhLFxuICAgIGlzSVBDRXJyb3JSZXNwb25zZSxcblxuICAgIElQQ1RyYW5zcG9ydEV2ZW50cyxcbiAgICBJUENUcmFuc3BvcnQsXG59IGZyb20gJy4vaW50ZXJmYWNlcyc7XG5cbmltcG9ydCBwcmVyZW5kZXJDYWxsc2l0ZSBmcm9tICcuLi8uLi8uLi91dGlscy9wcmVyZW5kZXItY2FsbHNpdGUnO1xuXG5cbmludGVyZmFjZSBSZXF1ZXN0T3B0aW9ucyB7XG4gICAgZGF0YTogSVBDUmVxdWVzdERhdGE7XG4gICAgc3luYzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNsYXNzIElQQ1Byb3h5IGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgICBwcml2YXRlIF90cmFuc3BvcnQ6IElQQ1RyYW5zcG9ydDtcbiAgICBwcml2YXRlIF9yZXF1ZXN0Q291bnRlcjogbnVtYmVyID0gMDtcbiAgICBwcml2YXRlIHJlYWRvbmx5IF9oYW5kbGVyczogeyBbbmFtZTogc3RyaW5nXTogRnVuY3Rpb24gfTtcblxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvciAodHJhbnNwb3J0OiBJUENUcmFuc3BvcnQpIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLl90cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG5cbiAgICAgICAgdGhpcy5faGFuZGxlcnMgPSB7fTtcblxuICAgICAgICB0aGlzLl90cmFuc3BvcnQucmVhZCgpO1xuICAgICAgICB0aGlzLl90cmFuc3BvcnQub24oSVBDVHJhbnNwb3J0RXZlbnRzLmRhdGEsIHJhd1BhY2tldCA9PiB0aGlzLl9vblJlYWQocmF3UGFja2V0KSk7XG4gICAgICAgIHRoaXMub24oJ3JlcXVlc3QnLCBkYXRhID0+IHRoaXMuX29uUmVxdWVzdChkYXRhKSk7XG4gICAgfVxuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBwcml2YXRlIF9zYXZlRXJyb3IgKGVycm9yOiBFeHRlcm5hbEVycm9yKTogYW55IHtcbiAgICAgICAgaWYgKGlzVGVzdENhZmVFcnJvckxpc3QoZXJyb3IpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgZXJyb3IuaXRlbXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5jYWxsc2l0ZSlcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5jYWxsc2l0ZSA9IHByZXJlbmRlckNhbGxzaXRlKGl0ZW0uY2FsbHNpdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgX29uUmVhZCAocGFja2V0OiBJUENQYWNrZXQpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgaWYgKHBhY2tldC50eXBlID09PSBJUENQYWNrZXRUeXBlLnJlc3BvbnNlKVxuICAgICAgICAgICAgdGhpcy5lbWl0KGByZXNwb25zZS0ke3BhY2tldC5pZH1gLCBwYWNrZXQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlcXVlc3QnLCBwYWNrZXQpO1xuICAgIH1cblxuICAgIHByaXZhdGUgYXN5bmMgX29uUmVxdWVzdCAocmVxdWVzdFBhY2tldDogSVBDUmVxdWVzdFBhY2tldCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBsZXQgcmVzdWx0RGF0YSA9IG51bGw7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdERhdGEgPSB7IHJlc3VsdDogYXdhaXQgdGhpcy5faGFuZGxlcnNbcmVxdWVzdFBhY2tldC5kYXRhLm5hbWVdKC4uLnJlcXVlc3RQYWNrZXQuZGF0YS5hcmdzKSB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmVzdWx0RGF0YSA9IHsgZXJyb3I6IHRoaXMuX3NhdmVFcnJvcihlcnJvcikgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlUGFja2V0OiBJUENSZXNwb25zZVBhY2tldCA9IHtcbiAgICAgICAgICAgIGlkOiAgIHJlcXVlc3RQYWNrZXQuaWQsXG4gICAgICAgICAgICB0eXBlOiBJUENQYWNrZXRUeXBlLnJlc3BvbnNlLFxuICAgICAgICAgICAgc3luYzogcmVxdWVzdFBhY2tldC5zeW5jLFxuXG4gICAgICAgICAgICBkYXRhOiByZXN1bHREYXRhXG4gICAgICAgIH07XG5cbiAgICAgICAgYXdhaXQgdGhpcy5fdHJhbnNwb3J0LndyaXRlKHJlc3BvbnNlUGFja2V0KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9jcmVhdGVQYWNrZXQgKG9wdHM6IFJlcXVlc3RPcHRpb25zKTogSVBDUmVxdWVzdFBhY2tldCB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDogICB0aGlzLl9yZXF1ZXN0Q291bnRlcisrLFxuICAgICAgICAgICAgdHlwZTogSVBDUGFja2V0VHlwZS5yZXF1ZXN0LFxuICAgICAgICAgICAgc3luYzogb3B0cy5zeW5jLFxuICAgICAgICAgICAgZGF0YTogb3B0cy5kYXRhXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfY3JlYXRlUGxhaW5FcnJvciAoZXJyb3JEYXRhOiBFcnJvcik6IEVycm9yIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoZXJyb3JEYXRhLm1lc3NhZ2UpO1xuXG4gICAgICAgIE9iamVjdC5hc3NpZ24oZXJyb3IsIGVycm9yRGF0YSk7XG5cbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2NyZWF0ZUVycm9yIChlcnJvckRhdGE6IEV4dGVybmFsRXJyb3IpOiBFeHRlcm5hbEVycm9yIHtcbiAgICAgICAgaWYgKGlzVGVzdENhZmVFcnJvckxpc3QoZXJyb3JEYXRhKSkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JMaXN0ID0gbmV3IFRlc3RDYWZlRXJyb3JMaXN0KCk7XG5cbiAgICAgICAgICAgIGVycm9yTGlzdC5pdGVtcyA9IGVycm9yRGF0YS5pdGVtcztcblxuICAgICAgICAgICAgcmV0dXJuIGVycm9yTGlzdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVQbGFpbkVycm9yKGVycm9yRGF0YSk7XG4gICAgfVxuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBwdWJsaWMgcmVnaXN0ZXIgKGZ1bmM6IEZ1bmN0aW9uIHwgRnVuY3Rpb25bXSwgY29udGV4dDogYW55ID0gbnVsbCk6IHZvaWQge1xuICAgICAgICBmdW5jID0gY2FzdEFycmF5KGZ1bmMpO1xuXG4gICAgICAgIGZ1bmMuZm9yRWFjaChmbiA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5faGFuZGxlcnNbZm4ubmFtZV0pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVyc1tmbi5uYW1lXSA9IGZuLmJpbmQoY29udGV4dCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgcHVibGljIGFzeW5jIGNhbGwgKHRhcmdldDogc3RyaW5nfEZ1bmN0aW9uLCAuLi5hcmdzOiBhbnlbXSk6IFByb21pc2U8YW55PiB7XG4gICAgICAgIGNvbnN0IG5hbWUgICAgICAgICAgICA9IHR5cGVvZiB0YXJnZXQgPT09ICdzdHJpbmcnID8gdGFyZ2V0IDogdGFyZ2V0Lm5hbWU7XG4gICAgICAgIGNvbnN0IHBhY2tldCAgICAgICAgICA9IHRoaXMuX2NyZWF0ZVBhY2tldCh7IGRhdGE6IHsgbmFtZSwgYXJncyB9LCBzeW5jOiBmYWxzZSB9KTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VQcm9taXNlID0gdGhpcy5vbmNlKGByZXNwb25zZS0ke3BhY2tldC5pZH1gKTtcblxuICAgICAgICBhd2FpdCB0aGlzLl90cmFuc3BvcnQud3JpdGUocGFja2V0KTtcblxuICAgICAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IHJlc3BvbnNlUHJvbWlzZTtcblxuICAgICAgICBpZiAoaXNJUENFcnJvclJlc3BvbnNlKGRhdGEpKVxuICAgICAgICAgICAgdGhyb3cgdGhpcy5fY3JlYXRlRXJyb3IoZGF0YS5lcnJvcik7XG5cbiAgICAgICAgcmV0dXJuIGRhdGEucmVzdWx0O1xuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgcHVibGljIGNhbGxTeW5jICh0YXJnZXQ6IHN0cmluZ3xGdW5jdGlvbiwgLi4uYXJnczogYW55W10pOiBhbnkge1xuICAgICAgICBjb25zdCBuYW1lICAgICAgICAgID0gdHlwZW9mIHRhcmdldCA9PT0gJ3N0cmluZycgPyB0YXJnZXQgOiB0YXJnZXQubmFtZTtcbiAgICAgICAgY29uc3QgcmVxdWVzdFBhY2tldCA9IHRoaXMuX2NyZWF0ZVBhY2tldCh7IGRhdGE6IHsgbmFtZSwgYXJncyB9LCBzeW5jOiB0cnVlIH0pO1xuXG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydC53cml0ZVN5bmMocmVxdWVzdFBhY2tldCk7XG5cbiAgICAgICAgbGV0IHJlc3BvbnNlUGFja2V0OiBJUENSZXNwb25zZVBhY2tldCA9IHRoaXMuX3RyYW5zcG9ydC5yZWFkU3luYygpO1xuXG4gICAgICAgIHdoaWxlIChyZXNwb25zZVBhY2tldC5pZCAhPT0gcmVxdWVzdFBhY2tldC5pZClcbiAgICAgICAgICAgIHJlc3BvbnNlUGFja2V0ID0gdGhpcy5fdHJhbnNwb3J0LnJlYWRTeW5jKCk7XG5cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSByZXNwb25zZVBhY2tldC5kYXRhO1xuXG4gICAgICAgIGlmIChpc0lQQ0Vycm9yUmVzcG9uc2UocmVzcG9uc2UpKVxuICAgICAgICAgICAgdGhyb3cgdGhpcy5fY3JlYXRlRXJyb3IocmVzcG9uc2UuZXJyb3IpO1xuXG4gICAgICAgIHJldHVybiByZXNwb25zZS5yZXN1bHQ7XG4gICAgfVxufVxuIl19