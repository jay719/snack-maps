"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Quarantine = exports.getQuarantineOptions = void 0;
const base_1 = __importDefault(require("./base"));
const quarantine_option_names_1 = __importDefault(require("../../configuration/quarantine-option-names"));
const types_1 = require("../../errors/types");
const runtime_1 = require("../../errors/runtime");
const DEFAULT_QUARANTINE_THRESHOLD = 3;
const DEFAULT_TEST_RUN_THRESHOLD = 5;
function _isQuarantineOption(option) {
    return Object.values(quarantine_option_names_1.default).includes(option);
}
function _validateQuarantineOptions(options) {
    const retryCount = options.retryCount || DEFAULT_TEST_RUN_THRESHOLD;
    const passCount = options.passCount || DEFAULT_QUARANTINE_THRESHOLD;
    if (passCount > retryCount)
        throw new runtime_1.GeneralError(types_1.RUNTIME_ERRORS.invalidRetryCountValue, passCount);
}
async function getQuarantineOptions(optionName, options) {
    if (typeof options === 'boolean')
        return true;
    const parsedOptions = await base_1.default(options, {
        skipOptionValueTypeConversion: true,
        async onOptionParsed(key, value) {
            if (!key || !value)
                throw new runtime_1.GeneralError(types_1.RUNTIME_ERRORS.optionValueIsNotValidKeyValue, optionName);
            return Number(value);
        }
    });
    if (Object.keys(parsedOptions).some(key => !_isQuarantineOption(key)))
        throw new runtime_1.GeneralError(types_1.RUNTIME_ERRORS.invalidQuarantineOption, optionName);
    _validateQuarantineOptions(parsedOptions);
    return parsedOptions;
}
exports.getQuarantineOptions = getQuarantineOptions;
class Quarantine {
    constructor() {
        this.attempts = [];
        this.testRunThreshold = DEFAULT_TEST_RUN_THRESHOLD;
        this.failedQuarantineThreshold = DEFAULT_QUARANTINE_THRESHOLD;
        this.passedQuarantineThreshold = DEFAULT_QUARANTINE_THRESHOLD;
    }
    getFailedAttempts() {
        return this.attempts.filter(errors => !!errors.length);
    }
    getPassedAttempts() {
        return this.attempts.filter(errors => errors.length === 0);
    }
    setPassedQuarantineThreshold(threshold) {
        this.passedQuarantineThreshold = threshold;
        this._setFailedThreshold();
    }
    setTestRunThreshold(threshold) {
        this.testRunThreshold = threshold;
        this._setFailedThreshold();
    }
    getNextAttemptNumber() {
        return this.attempts.length + 1;
    }
    isThresholdReached(extraErrors) {
        const { failedTimes, passedTimes } = this._getAttemptsResult(extraErrors);
        const failedThresholdReached = failedTimes >= this.failedQuarantineThreshold;
        const passedThresholdReached = passedTimes >= this.passedQuarantineThreshold;
        return failedThresholdReached || passedThresholdReached;
    }
    isFirstAttemptSuccessful(extraErrors) {
        const { failedTimes, passedTimes } = this._getAttemptsResult(extraErrors);
        return failedTimes === 0 && passedTimes > 0;
    }
    _getAttemptsResult(extraErrors) {
        let failedTimes = this.getFailedAttempts().length;
        let passedTimes = this.getPassedAttempts().length;
        if (extraErrors) {
            if (extraErrors.length)
                failedTimes += extraErrors.length;
            else
                passedTimes += 1;
        }
        return { failedTimes, passedTimes };
    }
    _setFailedThreshold() {
        if (this.testRunThreshold !== DEFAULT_TEST_RUN_THRESHOLD)
            this.failedQuarantineThreshold = this.testRunThreshold - this.passedQuarantineThreshold + 1;
        else
            this.failedQuarantineThreshold = DEFAULT_QUARANTINE_THRESHOLD;
    }
}
exports.Quarantine = Quarantine;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicXVhcmFudGluZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy91dGlscy9nZXQtb3B0aW9ucy9xdWFyYW50aW5lLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLGtEQUFvQztBQUNwQywwR0FBa0Y7QUFDbEYsOENBQW9EO0FBQ3BELGtEQUFvRDtBQUlwRCxNQUFNLDRCQUE0QixHQUFHLENBQUMsQ0FBQztBQUN2QyxNQUFNLDBCQUEwQixHQUFHLENBQUMsQ0FBQztBQUVyQyxTQUFTLG1CQUFtQixDQUFFLE1BQWM7SUFDeEMsT0FBTyxNQUFNLENBQUMsTUFBTSxDQUFDLGlDQUF1QixDQUFDLENBQUMsUUFBUSxDQUFDLE1BQWlDLENBQUMsQ0FBQztBQUM5RixDQUFDO0FBRUQsU0FBUywwQkFBMEIsQ0FBRSxPQUFvQztJQUNyRSxNQUFNLFVBQVUsR0FBRyxPQUFPLENBQUMsVUFBVSxJQUFJLDBCQUEwQixDQUFDO0lBQ3BFLE1BQU0sU0FBUyxHQUFJLE9BQU8sQ0FBQyxTQUFTLElBQUksNEJBQTRCLENBQUM7SUFFckUsSUFBSSxTQUFTLEdBQUcsVUFBVTtRQUN0QixNQUFNLElBQUksc0JBQVksQ0FBQyxzQkFBYyxDQUFDLHNCQUFzQixFQUFFLFNBQVMsQ0FBQyxDQUFDO0FBQ2pGLENBQUM7QUFFTSxLQUFLLFVBQVUsb0JBQW9CLENBQUUsVUFBa0IsRUFBRSxPQUF1RDtJQUNuSCxJQUFJLE9BQU8sT0FBTyxLQUFLLFNBQVM7UUFDNUIsT0FBTyxJQUFJLENBQUM7SUFFaEIsTUFBTSxhQUFhLEdBQUcsTUFBTSxjQUFjLENBQUMsT0FBTyxFQUFFO1FBQ2hELDZCQUE2QixFQUFFLElBQUk7UUFFbkMsS0FBSyxDQUFDLGNBQWMsQ0FBRSxHQUFXLEVBQUUsS0FBYTtZQUM1QyxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSztnQkFDZCxNQUFNLElBQUksc0JBQVksQ0FBQyxzQkFBYyxDQUFDLDZCQUE2QixFQUFFLFVB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LEtBQUssMEJBQTBCO1lBQ3BELElBQUksQ0FBQyx5QkFBeUIsR0FBRyxJQUFJLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLHlCQUF5QixHQUFHLENBQUMsQ0FBQzs7WUFFNUYsSUFBSSxDQUFDLHlCQUF5QixHQUFHLDRCQUE0QixDQUFDO0lBQ3RFLENBQUM7Q0FDSjtBQXRFRCxnQ0FzRUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYmFzZUdldE9wdGlvbnMgZnJvbSAnLi9iYXNlJztcbmltcG9ydCBRVUFSQU5USU5FX09QVElPTl9OQU1FUyBmcm9tICcuLi8uLi9jb25maWd1cmF0aW9uL3F1YXJhbnRpbmUtb3B0aW9uLW5hbWVzJztcbmltcG9ydCB7IFJVTlRJTUVfRVJST1JTIH0gZnJvbSAnLi4vLi4vZXJyb3JzL3R5cGVzJztcbmltcG9ydCB7IEdlbmVyYWxFcnJvciB9IGZyb20gJy4uLy4uL2Vycm9ycy9ydW50aW1lJztcbmltcG9ydCB7IERpY3Rpb25hcnkgfSBmcm9tICcuLi8uLi9jb25maWd1cmF0aW9uL2ludGVyZmFjZXMnO1xuaW1wb3J0IFRlc3RSdW5FcnJvckZvcm1hdHRhYmxlQWRhcHRlciBmcm9tICcuLi8uLi9lcnJvcnMvdGVzdC1ydW4vZm9ybWF0dGFibGUtYWRhcHRlcic7XG5cbmNvbnN0IERFRkFVTFRfUVVBUkFOVElORV9USFJFU0hPTEQgPSAzO1xuY29uc3QgREVGQVVMVF9URVNUX1JVTl9USFJFU0hPTEQgPSA1O1xuXG5mdW5jdGlvbiBfaXNRdWFyYW50aW5lT3B0aW9uIChvcHRpb246IHN0cmluZyk6IG9wdGlvbiBpcyBRVUFSQU5USU5FX09QVElPTl9OQU1FUyB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXMoUVVBUkFOVElORV9PUFRJT05fTkFNRVMpLmluY2x1ZGVzKG9wdGlvbiBhcyBRVUFSQU5USU5FX09QVElPTl9OQU1FUyk7XG59XG5cbmZ1bmN0aW9uIF92YWxpZGF0ZVF1YXJhbnRpbmVPcHRpb25zIChvcHRpb25zOiBEaWN0aW9uYXJ5PHN0cmluZyB8IG51bWJlcj4gKTogdm9pZCB7XG4gICAgY29uc3QgcmV0cnlDb3VudCA9IG9wdGlvbnMucmV0cnlDb3VudCB8fCBERUZBVUxUX1RFU1RfUlVOX1RIUkVTSE9MRDtcbiAgICBjb25zdCBwYXNzQ291bnQgID0gb3B0aW9ucy5wYXNzQ291bnQgfHwgREVGQVVMVF9RVUFSQU5USU5FX1RIUkVTSE9MRDtcblxuICAgIGlmIChwYXNzQ291bnQgPiByZXRyeUNvdW50KVxuICAgICAgICB0aHJvdyBuZXcgR2VuZXJhbEVycm9yKFJVTlRJTUVfRVJST1JTLmludmFsaWRSZXRyeUNvdW50VmFsdWUsIHBhc3NDb3VudCk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRRdWFyYW50aW5lT3B0aW9ucyAob3B0aW9uTmFtZTogc3RyaW5nLCBvcHRpb25zOiBzdHJpbmcgfCBib29sZWFuIHwgRGljdGlvbmFyeTxzdHJpbmcgfCBudW1iZXI+KTogUHJvbWlzZTxEaWN0aW9uYXJ5PG51bWJlcj4gfCBib29sZWFuPiB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnYm9vbGVhbicpXG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgY29uc3QgcGFyc2VkT3B0aW9ucyA9IGF3YWl0IGJhc2VHZXRPcHRpb25zKG9wdGlvbnMsIHtcbiAgICAgICAgc2tpcE9wdGlvblZhbHVlVHlwZUNvbnZlcnNpb246IHRydWUsXG5cbiAgICAgICAgYXN5bmMgb25PcHRpb25QYXJzZWQgKGtleTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKSB7XG4gICAgICAgICAgICBpZiAoIWtleSB8fCAhdmFsdWUpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEdlbmVyYWxFcnJvcihSVU5USU1FX0VSUk9SUy5vcHRpb25WYWx1ZUlzTm90VmFsaWRLZXlWYWx1ZSwgb3B0aW9uTmFtZSk7XG5cbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIodmFsdWUpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoT2JqZWN0LmtleXMocGFyc2VkT3B0aW9ucykuc29tZShrZXkgPT4gIV9pc1F1YXJhbnRpbmVPcHRpb24oa2V5KSkpXG4gICAgICAgIHRocm93IG5ldyBHZW5lcmFsRXJyb3IoUlVOVElNRV9FUlJPUlMuaW52YWxpZFF1YXJhbnRpbmVPcHRpb24sIG9wdGlvbk5hbWUpO1xuXG4gICAgX3ZhbGlkYXRlUXVhcmFudGluZU9wdGlvbnMocGFyc2VkT3B0aW9ucyk7XG5cbiAgICByZXR1cm4gcGFyc2VkT3B0aW9ucztcbn1cblxuXG5pbnRlcmZhY2UgQXR0ZW1wdFJlc3VsdCB7XG4gICAgZmFpbGVkVGltZXM6IG51bWJlcjtcbiAgICBwYXNzZWRUaW1lczogbnVtYmVyO1xufVxuXG5leHBvcnQgY2xhc3MgUXVhcmFudGluZSB7XG4gICAgcHVibGljIGF0dGVtcHRzOiBUZXN0UnVuRXJyb3JGb3JtYXR0YWJsZUFkYXB0ZXJbXVtdO1xuICAgIHB1YmxpYyB0ZXN0UnVuVGhyZXNob2xkOiBudW1iZXI7XG4gICAgcHVibGljIGZhaWxlZFF1YXJhbnRpbmVUaHJlc2hvbGQ6IG51bWJlcjtcbiAgICBwdWJsaWMgcGFzc2VkUXVhcmFudGluZVRocmVzaG9sZDogbnVtYmVyO1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yICgpIHtcbiAgICAgICAgdGhpcy5hdHRlbXB0cyA9IFtdO1xuICAgICAgICB0aGlzLnRlc3RSdW5UaHJlc2hvbGQgPSBERUZBVUxUX1RFU1RfUlVOX1RIUkVTSE9MRDtcbiAgICAgICAgdGhpcy5mYWlsZWRRdWFyYW50aW5lVGhyZXNob2xkID0gREVGQVVMVF9RVUFSQU5USU5FX1RIUkVTSE9MRDtcbiAgICAgICAgdGhpcy5wYXNzZWRRdWFyYW50aW5lVGhyZXNob2xkID0gREVGQVVMVF9RVUFSQU5USU5FX1RIUkVTSE9MRDtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0RmFpbGVkQXR0ZW1wdHMgKCk6IFRlc3RSdW5FcnJvckZvcm1hdHRhYmxlQWRhcHRlcltdW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRlbXB0cy5maWx0ZXIoZXJyb3JzID0+ICEhZXJyb3JzLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgcHVibGljIGdldFBhc3NlZEF0dGVtcHRzICgpOiBUZXN0UnVuRXJyb3JGb3JtYXR0YWJsZUFkYXB0ZXJbXVtdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0ZW1wdHMuZmlsdGVyKGVycm9ycyA9PiBlcnJvcnMubGVuZ3RoID09PSAwKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0UGFzc2VkUXVhcmFudGluZVRocmVzaG9sZCAodGhyZXNob2xkOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5wYXNzZWRRdWFyYW50aW5lVGhyZXNob2xkID0gdGhyZXNob2xkO1xuICAgICAgICB0aGlzLl9zZXRGYWlsZWRUaHJlc2hvbGQoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0VGVzdFJ1blRocmVzaG9sZCAodGhyZXNob2xkOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgdGhpcy50ZXN0UnVuVGhyZXNob2xkID0gdGhyZXNob2xkO1xuICAgICAgICB0aGlzLl9zZXRGYWlsZWRUaHJlc2hvbGQoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0TmV4dEF0dGVtcHROdW1iZXIgKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dGVtcHRzLmxlbmd0aCArIDE7XG4gICAgfVxuXG4gICAgcHVibGljIGlzVGhyZXNob2xkUmVhY2hlZCAoZXh0cmFFcnJvcnM/OiBUZXN0UnVuRXJyb3JGb3JtYXR0YWJsZUFkYXB0ZXJbXSk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCB7IGZhaWxlZFRpbWVzLCBwYXNzZWRUaW1lcyB9ID0gdGhpcy5fZ2V0QXR0ZW1wdHNSZXN1bHQoZXh0cmFFcnJvcnMpO1xuXG4gICAgICAgIGNvbnN0IGZhaWxlZFRocmVzaG9sZFJlYWNoZWQgPSBmYWlsZWRUaW1lcyA+PSB0aGlzLmZhaWxlZFF1YXJhbnRpbmVUaHJlc2hvbGQ7XG4gICAgICAgIGNvbnN0IHBhc3NlZFRocmVzaG9sZFJlYWNoZWQgPSBwYXNzZWRUaW1lcyA+PSB0aGlzLnBhc3NlZFF1YXJhbnRpbmVUaHJlc2hvbGQ7XG5cbiAgICAgICAgcmV0dXJuIGZhaWxlZFRocmVzaG9sZFJlYWNoZWQgfHwgcGFzc2VkVGhyZXNob2xkUmVhY2hlZDtcbiAgICB9XG5cbiAgICBwdWJsaWMgaXNGaXJzdEF0dGVtcHRTdWNjZXNzZnVsIChleHRyYUVycm9yczogVGVzdFJ1bkVycm9yRm9ybWF0dGFibGVBZGFwdGVyW10pOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgeyBmYWlsZWRUaW1lcywgcGFzc2VkVGltZXMgfSA9IHRoaXMuX2dldEF0dGVtcHRzUmVzdWx0KGV4dHJhRXJyb3JzKTtcblxuICAgICAgICByZXR1cm4gZmFpbGVkVGltZXMgPT09IDAgJiYgcGFzc2VkVGltZXMgPiAwO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2dldEF0dGVtcHRzUmVzdWx0IChleHRyYUVycm9ycz86IFRlc3RSdW5FcnJvckZvcm1hdHRhYmxlQWRhcHRlcltdKTogQXR0ZW1wdFJlc3VsdCB7XG4gICAgICAgIGxldCBmYWlsZWRUaW1lcyA9IHRoaXMuZ2V0RmFpbGVkQXR0ZW1wdHMoKS5sZW5ndGg7XG4gICAgICAgIGxldCBwYXNzZWRUaW1lcyA9IHRoaXMuZ2V0UGFzc2VkQXR0ZW1wdHMoKS5sZW5ndGg7XG5cbiAgICAgICAgaWYgKGV4dHJhRXJyb3JzKSB7XG4gICAgICAgICAgICBpZiAoZXh0cmFFcnJvcnMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZhaWxlZFRpbWVzICs9IGV4dHJhRXJyb3JzLmxlbmd0aDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBwYXNzZWRUaW1lcyArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgZmFpbGVkVGltZXMsIHBhc3NlZFRpbWVzIH07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfc2V0RmFpbGVkVGhyZXNob2xkICgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMudGVzdFJ1blRocmVzaG9sZCAhPT0gREVGQVVMVF9URVNUX1JVTl9USFJFU0hPTEQpXG4gICAgICAgICAgICB0aGlzLmZhaWxlZFF1YXJhbnRpbmVUaHJlc2hvbGQgPSB0aGlzLnRlc3RSdW5UaHJlc2hvbGQgLSB0aGlzLnBhc3NlZFF1YXJhbnRpbmVUaHJlc2hvbGQgKyAxO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmZhaWxlZFF1YXJhbnRpbmVUaHJlc2hvbGQgPSBERUZBVUxUX1FVQVJBTlRJTkVfVEhSRVNIT0xEO1xuICAgIH1cbn1cbiJdfQ==